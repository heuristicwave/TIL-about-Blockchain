

### 트러플 프레임워크 파헤치기 2



**Unit test**

unit 이라는 가장 작은 테스트가 가능한 부분을 올바른 동작을 위해 개별적 및 독립적으로 검사하는 절차다.

트러플은 2가지 서로 다른 방법으로 간단하면서 관리 할 수 있는 테스트를 작성할 수 있게한다.

1. 자바스크립트에서는 앱 클라이언트로부터의 컨트랙트를 테스트한다
2. 솔리디티에서는  다른 컨트랙트로부터 컨트랙트를 테스트한다.

모든 테스트 파일은 ./test 내에 있어야 한다. 트러플은 **.js .es .es6 .jsx .sol**의 확장자를 가진 테스트 파일만 실행한다.



**자바스크립트 내에서 테스트 작성**

트러플의 자바스크립트 테스트 프레임워크는 mocha 위에 구축돼 있다. mocha는 테스트 작성을 위한 자바스크립트 프레임워크이며, chai는 assertion 라이브러리다.

테스트 프레임워크는 테스트를 구성하고 실행하는데 사용되며, assertion은 결과가 올바른지 검증 할 수 있는 유틸리티를 제공한다.

<a href= https://mochajs.org > < a href=http://chaijs.com >

컨트랙트 추상화는 자바스크립트로부터 컨트랙트 상호작용을 가능하게 하는 기초다.

트러플은 테스트 내에서 어떤 컨트랙트와 상호작용하는지 탐지할 방법이 없으므로, 이러한 컨트랙트를 명시적으로 요청해야 한다. `artifacts.require()`메소드를 사용해 수행한다. 즉, 테스트 파일 내에서 첫 번째로 수행돼야 하는 작업은 테스트하길 원하는 컨트랙트의 추상화를 생성하는 것이다.

이후, 실제 테스트 부분이 작성돼야 한다. 구조적으로 테스트 파일은 mocha의 테스트 파일로부터 크게 다르지 않다. 테스트 파일은 mocha가 자동화된 테스트로 인식할 수 있도록 코드가 포함돼 있어야 한다. mocha와 트러플 테스트의 차이점은 contract() 함수다. 이 함수는 트러플에게 모든 마이그레이션을 실행하도록 시그널을 보내는 것을 제외하고는 describe()와 같은 방식으로 동작한다.

- 각 contract() 함수가 실행되기 전에, 컨트랙트는 실행 중인 이더리움 노드에 재배포되므로 깨끗한 컨트랙트 상태에서 테스트가 실행된다.
- contract() 함수는 테스트 작성 시에 사용할 수 있도록 이더리움 노드로부터 사용 가능한 계좌의 목록을 제공한다.



`metacoin.js`에 MetaCoin 컨트랙트를 테스트하기 위해 트러플로부터 생성된 기본 테스트 코드가 있다.

트러플은 mocha의 설정에 접근할 수 있으므로 mocha가 동작하는 방식을 변경할 수 있다. mocha의 설정은 truffle.js파일의 내보낸 객체 내의 mocha 속성 하위에 있다.

``` javascript
mocha: {
    useColors : true
}
```



**솔리디티로 테스트 작성**

솔리디티 테스트 코드는 .sol에 저장된다.

- 솔리디티 테스트는 어떠한 컨트랙트로부터 extend 돼서는 안 된다. 가능한 최소화 해서 만들고, 작성 컨트랙트에 대한 완전한 제어를 제공해준다.
- 트러플은 기본 assert 라이브러리를 제공하지만, 필요 시 언제든지 라이브러리 변경이 가능하다.
- 어떤 이더리움 클라이언트에 대해서도 솔리디티 테스트를 실행 할 수 있어야 한다.



트러플에 의해 생성된 기본 솔리디티 테스트 코드는 `TestMetacoin.sol`에서 찾을 수 있다.

-  Assert.equal()과 같은 단언문 함수는 truffle/Assert.sol에서 제공된다. 이는 기본 단언문 라이브러리나 올바른 단언문 이벤트를 트리거함으로써 트러플의 테스트 러너와 느슨하게 통합되는 한 자신의 단언문 라이브러리를 포함 할 수 있다. 트러플 내에서 솔리디티 단언문 라이브러리의 구조  < a href = https://github.com/trufflesuite/truffle/blob/beta/lib/testing/Assert.sol >
- 파일 이름 매칭은 대소문자를 구별한다. 즉 파일 이름이 대문자로 돼 있지 않으면 컨트랙트 이름 또한 대문자가 아니여야 한다.
- 솔리디티의 import 명령어를 사용해 컨트랙트 의존성을 정의 할 수 있다. 트러플은 정확한 순서대로 컨트랙트를 컴파일 할 것이며, 필요한 경우 라이브러리를 자동으로 링크 할 것이다. 의존성 ./ 또는 ../.로 시작하며 현재 솔리디티 파일에서 상대적 경로로 지정해야 한다.



**설정 파일**

`truffle.js` 파일은 프로젝트를 설정하기 위해 사용되는 자바스크립트 파일이다. 이 파일은 프로젝트를 위한 설정을 생성하는 데 필요하다면 어떠한 코드라도 수행할 수 있다. 이 파일은 프로젝트 설정을 나타내는 객체를 내보내기(export)해야 한다.

```
module.exports = {
 networks: {
  development: {
   host: 'localhost',
   port: 8545,
   network_id: '*'
  }
 }
}
```

 - cmd를 사용할 때 기본 설정 파일 이름은 트러플 실행 파일과의 충돌을 발생 시킬 수 있다. 만약 충돌한다면, 파워셸 또는 Git Bash를 사용하자. 또한 충돌을 피하고자 설정 파일의 이름을 `truffle-config.js`로 변경 할 수 있다.



**컨트랙트 배포**

작은 프로젝트라도 적어도 두 개의 블록체인과 상호작용한다. 하나는 EthereumJS TestRPC와 같은 개발자의 컴퓨터이며, 다른 하나는 개발자가 결국 애플리케이션을 최종적으로 배포할 네트워크(이더리움의 메인 네트워크, 프라이빗 컨소시엄 네트워크)를 나타낸다.

네트워크는 런타임에 컨트랙트 추상화에 의해 자동으로 탐지 되므로, 애플리케이션 또는 프론트엔드를 한 번만 배포하면 된다는 것을 의미한다. 애플리케이션이 동작 중이면, 실행 중인 이더리움 클라이언트는 어떤 아티팩트를 사용할지 결정하므로 응용프로그램이 유연해진다.

컨트랙트를 이더리움 네트워크에 배포하기 위한 코드를 포함하고 있는 자바스크립트 파일을 **Migration**이라고 부른다. 이 파일들은 배포 작업 준비를 담당하고, 시간이 지남에 따라 배포에 대한 요구 조건이 변경되리라는 것을 가정해 작성한다. 프로젝트가 진화할수록 새로운 마이그레이션 스크립트를 생성해 블록체인 위에서 이러한 진화를 진전시킨다. 기존에 실행되 마이그레이션의 기록은 Migrations 컨트랙트를 통해 블록체인에 기록된다.



**마이그레이션 파일**

Migratoins 컨트랙트는 Migratoins 폴더 내에서 마지막으로 적용된 마이그레이션 스크립트의 번호를 저장한다. (last_completed_migration 내에) Migrations 컨트랙트는 항상 가장 먼저 배포된다. 번호 부여 방식은 `x_script_name.js`이며 x는 1부터 시작한다.

Migrations 컨트랙트는 적용된 마지막 배포 스크립트의 번호를 저장하므로 트러플이 이 스크립트들을 다시 돌리지 않는다. 반면에 차후 애플리케이션에 수정이 필요하거나, 새로운 컨트랙트가 배포돼야 할 수 있다. 이를 위해서는 증가한 번호와 함께 새로운 스크립트를 생성하고 필요한 모든 절차를 기술해야 한다. 



**마이그레이션 작성**

마이그레이션 파일의 시작 부분에서는 artifacts.require() 메소드를 통해 상호작용하길 원하는 컨트랙트를 트러플에게 알려준다. 이 메소드는 Node의 require와 유사하지만, 여기서는 나머지 배포 스크립트 내에서 사용할 수 있는 컨트랙트 추상화를 리턴한다.

모든 마이그레이션은 `module.exports` 문법을 통해 함수를 내보내기해야 한다. 각 마이그레이션으로 부터 내보내기된 함수는 첫 번째 인자로 **deployer 객체**(배포 작업 준비를 위한 주요 인터페이스)를 받아들여야 한다. 이 객체는 스마트 컨트랙트를 배포하기 위한 명확한 API를 제공하고 배포된 아티팩트를 차후 사용을 위해 아티팩트 파일에 저장하거나 라이브러리를 링킹하는 등의 배포에 필요한 작업을 진행함으로써 배포 작업을 지원한다. 

- `deployer.deploy(contractAbstraction, args..., options)` : 컨트랙트 추상화 객체에 의해 지정된 특정 컨트랙트를 옵션 생성자 인자와 함께 배포한다. 싱글톤 컨트랙트의 경우 유용하므로 이 컨트랙트의 오직 하나의 인스턴스만 DApp을 위해 존재한다. 배포 이후 CA를 설정하고(artifact 내 address 속성은 새로 배포된 주소와 같다) 기존에 저장된 주소를 재정의 한다. 다수의 컨트랙트 배포 속도를 높이기 위해 선택적으로 컨트랙트의 배열, 배열의 배열을 전달할 수 있다. 마지막 인자는 overwrite라는 하나의 키를 포함할 수 있는 옵션 값이다. overwrite가 false로 설정되면, deployer는 이미 하나가 배포돼 있을 경우 배포하지 않을 것이다. 이 메소드는 프로미스를 리턴한다.
- `deployer.link(library, destinations)` : 이미 배포된 라이브러리를 컨트랙트 또는 다수의 컨트랙트에 링크한다. destinations 인자는 하나의 컨트랙트 추상화 또는 다수의 컨트랙트 추상화의 배열일 수 있다. destination 내 어떤 컨트랙트도 링크된 라이브러리에 의존하지 않는 경우 deployer는 해당 컨트랙트르 무시한다. 이 메소드는 프로미스를 리턴한다.
- `deployer.then(function(){})` : 임의의 배포 절차를 실행하기 위해 사용된다. 이를 사용해 마이그레이션 중 컨트랙트 데이터를 추가, 편집, 재구성하기 위해 특별한 컨트랙트를 호출 할 수 있다. 콜백 함수 내에서 컨트랙트를 배포하고 링크하기 위해서는 컨트랙트 추상화 API를 사용할 수 있다.

배포되는 네트워크에 따라 배포 절차를 조건부로 실행할 수도 있다. 배포 절차를 조건별로 준비하기 위해 network라고 불리는 두번째 매개변수를 받아들이는 마이그레이션을 작성한다. 

```
module.exports = {
	if (network != "live") {
		// 그렇지 않은 경우 다른 절차를 수행한다.
	} else {
        // "live" 네트워크의 경우에는 특정 작업을 수행한다.
	}
}
```



**2_deploy_contracts.js**

```javascript
var ConvertLib = artifacts.require("./ConvertLib.sol");
var MetaCoin = artifacts.require("./MetaCoin.sol");

module.exports = function(deployer) {
  deployer.deploy(ConvertLib);
  deployer.link(ConvertLib, MetaCoin);
  deployer.deploy(MetaCoin);
};
```

ConvertLib 및 MetaCoin 컨트랙트를 위한 추상화를  생성했다. 어떤 네트워크가 사용되는지와 상관 없이 CovertLib라이브러리를 배포하고, 라이브러리를 MetaCoin 네트워크와 링크하고, 최종적으로 MetaCoin 네트워크를 배포한다.

마이그레이션을 실행하기 위해서 배포하는 명령어

```shell
truffle migrate --network development
```

위 명령은 자동으로 ConvertLib 라이브러리 및 아티팩트 파일 내의 MetaCoin 컨트랙트 주소를 업데이트하고, 링크를  업데이트하는 것을 알 수 있다.

- --reset : 마지막으로 완료된 마이그레이션부터 실행하는 대신 처음부터 모든 마이그레이션을 실행한다.
- --f number : 특정 마이그레이션으로부터 컨트랙트를 실행한다.



---

위 web3관련 정보는 `이더리움을 활용한 블록체인 프로젝트 구축 - 나라얀 프루스티 `이라는 책을보고 정리 하였습니다. 